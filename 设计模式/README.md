# 设计模式

* 内容参考：深入设计模式 v2020-1-20

* 设计模式六大原则
* 设计模式详解

## 一、前置知识

* 面向对象编程的四个基本概念
  * 抽象：反映真实世界对象的特定内容，忽然不要需要的内容
  * 封装：一个对象对其他对象隐藏部分状态，仅暴漏有限接口
  * 继承：根据已有类创建新的类，复用一些已有的内容
  * 多态：程序能够检测对象的实际类，调用对应的接口
* 对象之间的关系（从强到弱，每一级都是后一级的强化版）
  * 继承：类 A 继承类 B 的接口和实现，并扩展内容
  * 实现：类 A 实现类 B 的接口内容，类 B 通常是纯虚类
  * 组合：对象 A 知道对象 B，成员中有 B，且管理着 B 的生命周期
  * 聚合：对象 A 知道对象 B，通过指针调用 B，但是 B 独立存在
  * 关联：对象 A 知道对象 B
  * 依赖：对类 B 进行修改会影响到类 A

##  二、六大设计原则（SOLID + 最少知道原则）
### 1、单一职责原则

* 每一个类只实现一个功能
* 例：“文件处理”需求
  * 违反原则：fileManager 类中写三个函数，分别是读文件、写文件、打日志
  * 遵循原则：将三个函数写成三个类，fileManager 类调用这三个类
* 优势：更清晰的职责分离，容易扩展、方便维护
* 劣势：不要过度拆分，否则得不偿失

###  2、开闭原则

* 类的拓展是开放的，类的修改是封闭的
* 例：订单类中，需要一个计算运费功能
  * 违反原则：一个计费功能，内部硬编码： if (陆运) 、if (海运)，需要添加空运功能的时候，要修改历史代码
  * 遵循原则：实现一个计费功能接口，陆运、海运通过继承实现具体内容，需要添加空运时，拓展一个子类即可
* 优势：当系统经常需要扩展功能时，十分使用
* 劣势：需要投入时间增加抽象层次

### 3、里氏替换原则

* 子类可以实现父类的抽象方法（多态），增加自己的方法，但不可以更改父类的方法
* 例：一个正方形类，继承矩形类。矩形类两个参数 w 、h，面积 s = w * h
  * 违反原则：正方形类中，s = w * w，修改了父类的
  * 遵循原则：在正方形类中也使用 w 、h 两个参数。或者抽象出一个 shape 类，然后将矩形和正方形当成平行的子类
* 优势：确保继承体系中子类和父类行为一致，防止不规范的多态产生的矛盾
* 劣势：不允许子类重写父类已声明的方法

###  4、接口隔离原则

* 接口应该尽量小而精，将一个通用接口拆分成多个专用接口
* 例子：一个关于动物行为的接口，内部有 eat、run、fly、swim 这几个纯虚函数，现在要定义 狗、猫、鱼、鸟，这几个动物类
  * 违反原则：纯虚函数要求子类继承时必须实现，导致每个动物都有浪费的地方，比如鱼不需要 run 功能、鸟不需要 swim 功能
  * 遵循原则：将接口中的每一个函数都拆成一个单独的接口，每个动物按需自取
* 优势：减少依赖、更灵活、风险更低、可读性更强

###  5、依赖倒置原则

* 高层模块不直接依赖底层模块，只依赖于底层模块封装出来的抽象接口
* 例子：类 A 依赖类 B，现在想要改为依赖类 C。A是高层模块，负责负责的业务逻辑。B 和 C 是底层模块，负责基本的原子操作
  * 违反原则：直接修改类 A，会造成不必要的风险
  * 遵循原则：类 A 在实现时，就使用抽象类，而抽象类通过 B 和 C 实现
* 优点：底层模块的修改不影响高层模块。支持面向接口编程

###  6、最少知道原则

* 只和自己直接持有的对象交互，不通过链式调用访问其他对象，不依赖全局变量
* 例子：类 A、B、C中，A 有一个 B 的对象，B 有一个 C 的对象
  * 违反原则：A.B.C.par 访问了非直接拥有的对象
  * 遵循原则：在 B 中实现一个函数 返回 C.par，然后 A.B.func 实现目标
* 低耦合、高内聚



## 二、创建型模式

### 1、工厂模式

* 在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型
* 问题：一款物流软件，大部分代码都在 卡车类 中。现希望支持海运功能

![](D:\Wins\Pictures\Saved Pictures\1634625228(1).jpg)

## 三、结构型模式






## 四、行为模式
