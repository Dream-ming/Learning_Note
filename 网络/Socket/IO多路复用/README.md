# IO多路复用

## Socket多线程操作

在Socket通信中，服务端有两类文件描述符，一个用于监听的，N个用于通信的

监听描述符的读缓冲区会等待客户端的connect请求，accept检测到读缓冲区有数据就会读出数据建立连接，否则一直阻塞

通信描述符的读缓冲区会等待客户端的send或者write请求，read或recv检测到读缓冲区有数据就会读出来，否则一直阻塞

通信描述符的写缓冲区，write或send操作，当写缓冲区有位置时，就写入并发送给客户端，否则阻塞

客户端的读写缓冲区操作类似

如果只有单线程，那么上述的阻塞会相互影响，read阻塞了就无法write或accept，于是有了多线程的Socket

## IO多路复用技术

IO多路复用：把检测文件描述符的读写缓冲区的操作交给内核，系统不必创建进程/线程，降低了系统开销

有select、poll、epoll三种函数

* select
  * 线性表存储文件描述符
  * 文件描述符有上限，一般是1024，可以修改源码，重新编译内核，但不建议
  * 将文件描述符集合拷贝到内核态，由内核遍历线性表，检查事件，再把集合拷贝回用户态，用户态遍历找到就绪的Socket
* poll
  * 链表存储文件描述符
  * 解决了 select 文件描述符集合上限小的问题
  * 两次拷贝和两次遍历的问题没有解决
* epoll
  * 红黑树直接在内核监控文件描述符，节约用户态到内核态的拷贝。但是 epoll_wait() 仍然需要从内核态拷贝到用户态
  * 同时在内核维护一个链表，当有事件就绪时，通过回调函数，将就绪的文件描述符加入链表，节约遍历的消耗
  * ET - 边缘触发 - 文件描述符就绪后，仅通知一次
  * LT - 水平触发 - 文件描述符就绪后，只要没有读完数据，就一直通知
  * epolloneshot，一个线程开始处理一个文件描述符后，该 fd 再次有数据可读，为避免另一个线程过来处理此 fd，可以通过 epoll_ctl 对该 fd 注册 epolloneshot 事件，当前线程处理完后，充值 epolloneshot 即可
